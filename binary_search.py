# Сложность данного алгоритма O(log n), логарифмическое время.
# O(log n)  = log2(n). Основание(2) в 'Big O' опускается, поэтому пишется как O(log n)
# Сложность высчитывается как: в какую степень нужно возвести основание(2) чтобы получить n(длина списка)
# К примеру при списке в 16 элементов сложность будет вида: log2(16) = 4

def binary_searh(list, item):
    low = 0  # В low и high хранятся границы той части списка, в которой происходит поиск
    high = len(list) - 1

    while low <= high:  # Пока эти границы не сократились до 1 элемента

        mid = (low + high) // 2  # Проверяем средний элемент
        guess = list[mid]

        if guess == item:  # Значение найдено.
            return mid  # Вернуть индекс загаданного числа

        if guess > item:  # Если много отрезаем сразу половину массива с середины до последнего
            high = mid - 1

        else:
            low = mid + 1  # Если мало отрезаем с первого элемента по середину
    return None  # Если загаданного числа в массиве нет


list = [5, 12, 17, 21, 26, 36, 41, 46, 49, 56, 57, 59, 61, 69, 76, 77, 79, 80, 87, 88, 91, 97]

print(binary_searh(list, 76))
